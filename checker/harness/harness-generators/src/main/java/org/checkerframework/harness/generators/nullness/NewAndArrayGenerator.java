package org.checkerframework.harness.generators.nullness;

import org.checkerframework.harness.core.CodeGenerator;

import java.io.BufferedWriter;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.text.DecimalFormat;
import java.util.ArrayList;
import java.util.Formatter;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Random;

/**
 * Generates Java sources that exercise object and array allocations: - new Object() - new
 * ArrayList<>() - new int[...], new String[...] - anonymous class: {@code new Runnable(){ ... }}
 *
 * <p>Behavior: - Emits one public class per file; file count equals {@code max(1,
 * req.sampleCount())}. - Per-file work is controlled by {@code extra["groupsPerFile"]} (default
 * 20); each group emits six allocation expressions. - Output is deterministic for the same seed,
 * sample count, and extras.
 *
 * <p>Optional extras: - groupsPerFile: int, default 20
 */
public final class NewAndArrayGenerator implements CodeGenerator {

    private static final String DEFAULT_PACKAGE = "bench.nullness.newarray";
    private static final String DEFAULT_CLASS_PREFIX = "ManyNew";

    @Override
    public String name() {
        return "NewAndArray";
    }

    @Override
    public GenerationResult generate(GenerationRequest req) throws Exception {
        final String packageName = DEFAULT_PACKAGE;
        final String classPrefix = DEFAULT_CLASS_PREFIX;
        final int groupsPerFile =
                parsePositiveInt(req.extra() == null ? null : req.extra().get("groupsPerFile"), 20);

        final Path sourcesDir = req.outputDir().resolve(name() + "-sources");
        Files.createDirectories(sourcesDir);

        List<Path> created = new ArrayList<>(Math.max(1, req.sampleCount()));
        final int fileCount = Math.max(1, req.sampleCount());
        final int pad = numDigits(fileCount);

        // Seeded RNG: ensures deterministic but seed-dependent output content
        final Random rng = new Random(req.seed());
        for (int i = 0; i < fileCount; i++) {
            String simpleClassName = classPrefix + "_" + leftPad(i + 1, pad);
            Path file = sourcesDir.resolve(simpleClassName + ".java");
            // Derive a per-file RNG to avoid cross-file dependence on loop iteration counts
            Random fileRng = new Random(rng.nextLong());
            writeOneFile(file, packageName, simpleClassName, groupsPerFile, fileRng, req.seed());
            created.add(file);
        }

        Map<String, Object> meta = new LinkedHashMap<>();
        meta.put("generator", name());
        meta.put("files", fileCount);
        meta.put("groupsPerFile", groupsPerFile);
        meta.put("packageName", packageName);
        meta.put("classPrefix", classPrefix);
        meta.put("seed", req.seed());

        return new GenerationResult(sourcesDir, created, meta);
    }

    private static void writeOneFile(
            Path file, String packageName, String className, int groups, Random rng, long seed)
            throws IOException {
        StringBuilder sb = new StringBuilder(256 + groups * 200);
        try (Formatter fmt = new Formatter(sb, Locale.ROOT)) {
            // Generated file header for traceability
            fmt.format(
                    "// Generated by NewAndArrayGenerator; groupsPerFile=%d; seed=%d%n",
                    groups, seed);
            fmt.format("// Package: %s | Class: %s%n%n", packageName, className);
            if (!packageName.isEmpty()) {
                fmt.format("package %s;%n%n", packageName);
            }
            fmt.format("import java.util.*;%n%n");
            fmt.format("public class %s {%n", className);

            // Small generic box to include a constructor allocation and a field write.
            // Uses Object upper bound to avoid initialization-checker interaction; compiles
            // cleanly with the Nullness Checker alone.
            fmt.format(
                    "  static class Box<T extends Object> { T t; Box(){ this.t = (T)(Object)new Object(); } }%n");

            fmt.format("  void f() {%n");
            for (int i = 0; i < groups; i++) {
                // Seed-influenced small variations that do not change structure/line count
                int arrLen1 = 8 + (Math.abs(rng.nextInt()) % 17); // [8,24]
                int arrLen2 = 8 + (Math.abs(rng.nextInt()) % 17); // [8,24]
                // Emit six allocation forms per group
                fmt.format("    Object o%d = new Object();%n", i);
                fmt.format("    ArrayList<String> l%d = new ArrayList<>();%n", i);
                fmt.format("    Box<String> b%d = new Box<>();%n", i);
                fmt.format("    int[] ai%d = new int[%d];%n", i, arrLen1);
                fmt.format("    String[] as%d = new String[%d];%n", i, arrLen2);
                fmt.format("    Runnable r%d = new Runnable(){ public void run(){} };%n", i);
            }
            fmt.format("  }%n"); // end method
            fmt.format("}%n"); // end class
        }

        Files.createDirectories(file.getParent());
        try (BufferedWriter w = Files.newBufferedWriter(file, StandardCharsets.UTF_8)) {
            w.write(sb.toString());
        }
    }

    private static int parsePositiveInt(String s, int def) {
        if (s == null) return def;
        try {
            int v = Integer.parseInt(s.trim());
            return v > 0 ? v : def;
        } catch (NumberFormatException e) {
            return def;
        }
    }

    private static int numDigits(int n) {
        if (n <= 0) return 1;
        return (int) Math.floor(Math.log10(n)) + 1;
    }

    private static String leftPad(int value, int width) {
        String pattern = repeat('0', width);
        return new DecimalFormat(pattern).format(value);
    }

    private static String repeat(char ch, int count) {
        StringBuilder sb = new StringBuilder(count);
        for (int i = 0; i < count; i++) sb.append(ch);
        return sb.toString();
    }
}
